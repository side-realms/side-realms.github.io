<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Containers on お茶は綾鷹派</title>
    <link>http://side-realms.github.io/container/</link>
    <description>Recent content in Containers on お茶は綾鷹派</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 30 Aug 2023 18:59:45 +0900</lastBuildDate><atom:link href="http://side-realms.github.io/container/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>自作 strace</title>
      <link>http://side-realms.github.io/container/strace/</link>
      <pubDate>Wed, 30 Aug 2023 18:59:45 +0900</pubDate>
      
      <guid>http://side-realms.github.io/container/strace/</guid>
      <description>おすすめのガンプラ，随時募集しています
strace seccomp がよく分からなかったので監視系で strace を作ってみる
strace はプロセスが使ってるシステムコールとかの呼び出しをトレースできる
strace は ptrace(2) でプロセスを監視しており，これによって呼び出されるシステムコールや その引数を見ている．
第一引数で ptrace リクエストの内容（？），第二引数にプロセスの pid を指定する．
long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data); 他プロセスをトレースするためには，対象のプロセスにアタッチし，一時的に親になる必要がある． ptrace が実行されると，トレーサーは，システムコールを呼び出したタイミングなどで 子プロセスに停止するよう命令し，カーネルは子プロセスを SIGTRAP で停止する．
strace を作る まずはアタッチ・デタッチの動きをみるだけ
int main(int argc, char *argv[]){ if(argc &amp;lt; 2){ fprintf(stderr, &amp;#34;pid needs\n&amp;#34;); exit(1); } pid_t pid = atoi(argv[1]); printf(&amp;#34;attach to PID: %d\n&amp;#34;, pid); long ret = ptrace(PTRACE_ATTACH, pid, NULL, NULL); if(ret&amp;lt;0){ perror(&amp;#34;atttach failed&amp;#34;); exit(1); } printf(&amp;#34;attached to %d\n&amp;#34;, pid); sleep(5); ret = ptrace(PTRACE_DETACH, pid, NULL, NULL); if(ret&amp;lt;0){ perror(&amp;#34;failed to detach&amp;#34;); exit(1); } printf(&amp;#34;detached from %d\n&amp;#34;, pid); return 0; } この状態で top コマンドを打ち，動きを見てみると sleep(5) の間，top コマンドの動きが止まっていることが分かる． これはさっき書いた「カーネルは子プロセスを SIGTRAP で停止する」の部分． ptrace されるプロセスは，シグナルごとにいちいち停止するので，waitpid で状態を確認する必要があるらしい．</description>
    </item>
    
    <item>
      <title>Namespace</title>
      <link>http://side-realms.github.io/container/namespace/</link>
      <pubDate>Wed, 30 Aug 2023 10:04:30 +0900</pubDate>
      
      <guid>http://side-realms.github.io/container/namespace/</guid>
      <description>モンエナ スイカ味，ほんとうにまずい
namespace namespace は，プロセスをグループ化して隔離空間を作り出すのに一役買っている． namaspace 大まかな機能があるわけではなく，隔離したいリソースごとに機能が分離している． (mount namespace, PID namespace とか)
OS 起動時にはデフォルトの namespace が存在し，全てのプロセスが属している． このうえで，そのリソースを隔離させたいかを指定してコンテナを作る．
unshare unshare &amp;ndash;mount とか unshare &amp;ndash;pid みたいな感じで namespace を作る． ネットワーク以外はこれで隔離できるらしい 各プロセスが動作している namespace に関する情報は /proc/[PID]/ns で見れる．
ここに表示されている数字が同じなら同じ namespace に属している． この /proc/[PID]/ns は，プロセスを既存の namespace で動かしたいときに使うこともある． setns は既存の namespace でプロセスを動かすことを実現するが(https://tenforward.hatenablog.com/entries/2014/08/14)，このときの引数にさっきの ns 指定される．
mount namespace ファイルシステムを特定のディレクトリに関連付けるための処理をマウントといい， マウントが行われるディレクトリをマウントポイントという． あるパーティション(例えば /dev/sdc1)にファイルシステムを作ってルートとしてマウントした場合， ルートがマウントポイントになる． この下に別のファイルシステムをマウントすることもできる．
mount namespace は，その namespace 内のプロセスから見えるマウントポイントを分離する． なので，ある mount namespace から別の mount namespace を見たときにそのマウントポイントが見えない． コンテナごとに独立したファイルシステムを使うことができる．
/root/hosts ファイルをバインドマウント先として /etc/hosts をマウントする． ファイルを確認すると同じ内容が見えることが分かる．</description>
    </item>
    
    <item>
      <title>コンテナ入門する</title>
      <link>http://side-realms.github.io/container/nyuumon/</link>
      <pubDate>Tue, 29 Aug 2023 19:51:30 +0900</pubDate>
      
      <guid>http://side-realms.github.io/container/nyuumon/</guid>
      <description>昆虫ロック弾けるようになりたい
コンテナ コンテナはプロセス自体は同じ OS で動いていて，これを OS のカーネル機能によって隔離する． 使えるリソースを分離して，ホスト OS で動くプロセスとか他のコンテナから独立した空間を作る． カーネルに「コンテナ」の仕組みがあるわけではなく，namespace とか cgroup みたいな いくつかのシステムを組み合わせてコンテナを作っている． なので Docker や LXC で作りが違う
メリット コンテナはプロセスなので起動速度はプロセスに近い VM と比較してエミュレートの必要がないためオーバーヘッドがすくない アプリケーションだけをコンテナ起動できる デメリット 異なる OS 用のバイナリは動かない 基本のカーネルは同じなのでカーネルの操作はできない 基本技術 CRI/OCI CRI: ユーザからの要求を受けてコンテナとの通信をする．イメージの取得や展開，ネットワークのセットアップなど．コンテナの直接の操作は低レイヤランタイムに命令を出す．containerd とか CRI-O. OCI: 高レイヤランタイムから命令を受けて，コンテナとして実行するプロセスをホストから分離して実行する．runc とか crun. レイヤ コンテナイメージはレイヤの集合体で，コンテナ実行時にこれらがマージされる．
layer:ルートファイルシステムのデータ .json:実行環境を再現するための情報 ファイルシステム コンテナ内とホストではファイルシステムを分離したいことが多い． このとき，ホスト内にあるディレクトリをコンテナの root ディレクトリにする．
chroot: プロセスのルートディレクトリを変更することができる． ただし jailbreak が可能なので chroot を使う場合はコンテナの chroot の capability を剥脱する必要があるが(CAP_SYS_CHROOT)，ユースケース的に不便なことも多いのでデフォルトでは剥奪しない． 代わりに pivot_root を使う
pivot_root: ルートファイルシステムを入れ替える． ファイルシステムごとに入れ替えるので，コンテナ側からは root のファイルシステムを見ることはできない． また，pivot_root には厳しい条件がある．</description>
    </item>
    
  </channel>
</rss>
